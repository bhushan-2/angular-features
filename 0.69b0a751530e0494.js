"use strict";(self.webpackChunkangular_versions=self.webpackChunkangular_versions||[]).push([[0],{4e3:(g,l,r)=>{r.r(l),r.d(l,{Angular8Module:()=>a});var d=r(6895),s=r(8478),e=r(4650);const u=function(){return["/"]};class i{constructor(){this.lazyLoading="\n  It means lazy-loaded import that looked like this:\n  \n  { path: '/student', loadChildren: './student/student.module#StudentModule' }  \n  \n  Will be looked like this:\n  \n  { path: '/student', loadChildren: () => import('./student/student.module').then(s => s.StudentModule) }"}}i.\u0275fac=function(t){return new(t||i)},i.\u0275cmp=e.Xpm({type:i,selectors:[["app-angular8"]],decls:34,vars:3,consts:[[1,"container-fluid"],[1,"row"],[1,"col-md-12","pd-0"],[1,"angular"],[1,"back",3,"routerLink"],[1,"row","features-scroll"],[1,"col-md-12"],[1,"feature"],[1,"terminal"],["src","./assets/differential_loading.jpg","alt","Differential loading",1,"diff-laoding"],["src","./assets/service_workers.jpg","alt","Differential loading",1,"service-worker"]],template:function(t,p){1&t&&(e.TgZ(0,"div",0)(1,"div",1)(2,"div",2)(3,"div",3)(4,"label"),e._uU(5,"Angular 8 Features"),e.qZA(),e.TgZ(6,"div"),e._uU(7,"(Released on 2019)"),e.qZA(),e.TgZ(8,"div",4),e._uU(9," < Back"),e.qZA()()()(),e.TgZ(10,"div",5)(11,"div",6)(12,"div",7)(13,"label"),e._uU(14,"1. New lazy loading syntax"),e.qZA(),e.TgZ(15,"p"),e._uU(16," Lazy loading feature modules has been a best practice in Angular for quite a while. That hasn\u2019t changed in version 8, but in place of the proprietary syntax to enable lazy loading, the framework has adopted the more common dynamic import syntax used widely in client-side web development. The new syntax relies less on parsing class names from strings and enables editors and IDEs to check that you\u2019re importing the correct items. "),e.qZA(),e.TgZ(17,"div",8)(18,"pre"),e._uU(19),e.qZA()()(),e.TgZ(20,"div",7)(21,"label"),e._uU(22,"2. Differential loading"),e.qZA(),e.TgZ(23,"p"),e._uU(24," Command Line Interface (CLI) will now produce separate bundles for modern JavaScript (ES2015+) and legacy JavaScript (ES5). Advanced modern browsers with ES2015+ support will be able to download more productive app bundles. It removes the overhead of browser compatibility. It also improves the page loading time and reduces the amount of time it takes for the page content to become interactive for users. "),e.qZA(),e.TgZ(25,"div"),e._UZ(26,"img",9),e.qZA()(),e.TgZ(27,"div",7)(28,"label"),e._uU(29,"3. Service Workers"),e.qZA(),e.TgZ(30,"p"),e._uU(31," Service workers function as a network proxy. They intercept all outgoing HTTP requests made by the application and can choose how to respond to them. For example, they can query a local cache and deliver a cached response if one is available. Proxying isn't limited to requests made through programmatic APIs, such as fetch; it also includes resources referenced in HTML and even the initial request to index.html. Service worker-based caching is thus completely programmable and doesn't rely on server-specified caching headers. "),e.qZA(),e.TgZ(32,"div"),e._UZ(33,"img",10),e.qZA()()()()()),2&t&&(e.xp6(8),e.Q6J("routerLink",e.DdM(2,u)),e.xp6(11),e.Oqu(p.lazyLoading))},dependencies:[s.rH],styles:[".diff-laoding[_ngcontent-%COMP%]{width:420px!important}.service-worker[_ngcontent-%COMP%]{width:650px}"]});const c=[{path:"",component:i}];class n{}n.\u0275fac=function(t){return new(t||n)},n.\u0275mod=e.oAB({type:n}),n.\u0275inj=e.cJS({imports:[s.Bz.forChild(c),s.Bz]});class a{}a.\u0275fac=function(t){return new(t||a)},a.\u0275mod=e.oAB({type:a}),a.\u0275inj=e.cJS({imports:[d.ez,n]})}}]);