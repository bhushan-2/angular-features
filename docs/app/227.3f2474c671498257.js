"use strict";(self.webpackChunkangular_versions=self.webpackChunkangular_versions||[]).push([[227],{4227:(g,u,a)=>{a.r(u),a.d(u,{Angular6Module:()=>o});var c=a(6895),l=a(3329),e=a(4650);const d=function(){return["/"]};class i{constructor(){this.elementRef="@ViewChild('login') login: ElementRef<HTMLInputElement>;\n\n  ngAfterViewInit() {\n  \n    this.loginInput.nativeElement.focus();\n  \n  }",this.service="@Injectable({\n    providedIn: 'root'\n  })\n  export class UserService {}",this.rxjs="\n  import { Observable, of } from 'rxjs';\n\n  import { map } from 'rxjs/operators';\n  \n  const squares$: Observable<number> = of(1, 2).pipe(map(n => n * n));"}}i.\u0275fac=function(n){return new(n||i)},i.\u0275cmp=e.Xpm({type:i,selectors:[["app-angular6"]],decls:36,vars:5,consts:[[1,"container-fluid"],[1,"row"],[1,"col-md-12","pd-0"],[1,"angular-6"],[1,"back",3,"routerLink"],[1,"row","features-scroll"],[1,"col-md-12"],[1,"feature"],[1,"terminal"]],template:function(n,s){1&n&&(e.TgZ(0,"div",0)(1,"div",1)(2,"div",2)(3,"div",3)(4,"label"),e._uU(5,"Angular 6 Features"),e.qZA(),e.TgZ(6,"div"),e._uU(7,"(Released on April 2018)"),e.qZA(),e.TgZ(8,"div",4),e._uU(9,"< Back"),e.qZA()()()(),e.TgZ(10,"div",5)(11,"div",6)(12,"div",7)(13,"label"),e._uU(14,"1. ElementRef"),e.qZA(),e.TgZ(15,"p"),e._uU(16," In previous versions of Angular, when we want to create the reference of an element in the template, we can use @ViewChild or @ViewChildren or inject the host using ElementRef directly. But, the problem is that ElementRef had its nativeElement property typed like any other element. But now in Angular 6, we can use type ElementRef more strictly if we want. "),e.qZA(),e.TgZ(17,"div",8)(18,"pre"),e._uU(19),e.qZA()()(),e.TgZ(20,"div",7)(21,"label"),e._uU(22,"2. New method of registering a service"),e.qZA(),e.TgZ(23,"p"),e._uU(24," There is a new way to define an injectable service in Angular 6. With this new way, we can register a provider directly inside the @Injectable() decorator, using the new providedIn attribute. It accepts \u2018root\u2019 as a value or any module name from our application. When we use \u2018root,\u2019 it means this injectable will be registered as a singleton object in the application and we don\u2019t need to add it to the providers of the root modules. "),e.qZA(),e.TgZ(25,"div",8)(26,"pre"),e._uU(27),e.qZA()()(),e.TgZ(28,"div",7)(29,"label"),e._uU(30,"3. RxJS 6.0"),e.qZA(),e.TgZ(31,"p"),e._uU(32," Angular 6 now used RxJS 6 internally. So we need to update our application accordingly. These changes provide developers an increase in performance and are easier to debug AJAX call stacks and improve modularity also, making it as backward compatible as possible. But RxJS changed the way we import things. "),e.qZA(),e.TgZ(33,"div",8)(34,"pre"),e._uU(35),e.qZA()()()()()()),2&n&&(e.xp6(8),e.Q6J("routerLink",e.DdM(4,d)),e.xp6(11),e.Oqu(s.elementRef),e.xp6(8),e.Oqu(s.service),e.xp6(8),e.Oqu(s.rxjs))},dependencies:[l.rH],styles:[".angular-6[_ngcontent-%COMP%]{width:100%;padding:10px;background:#1976d2}.angular-6[_ngcontent-%COMP%]   label[_ngcontent-%COMP%]{font-size:16px;font-weight:600;color:#fff;margin-left:20px}.angular-6[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]{font-size:12px;font-weight:400;color:#ccc;display:inline-block;margin-left:10px}"]});const p=[{path:"",component:i}];class t{}t.\u0275fac=function(n){return new(n||t)},t.\u0275mod=e.oAB({type:t}),t.\u0275inj=e.cJS({imports:[l.Bz.forChild(p),l.Bz]});class o{}o.\u0275fac=function(n){return new(n||o)},o.\u0275mod=e.oAB({type:o}),o.\u0275inj=e.cJS({imports:[c.ez,t]})}}]);